## 静态字段
静态字段被类的所有实例共享，所有实例都访问内存中同一的位置。因此，如果某个实例改变了该内存位置的值，这种改变对所有实例都是可见的。

对静态字段的访问除了可以对字段加`Public`修饰符还可以通过添加`using Static System.xxxxClassName`引用声明来直接访问类中的静态字段（该种方法不可以需要用`类名.字段名`的方式，直接使用`字段名`即可）。

静态成员的生存周期与实力成员不同，即使类没有实力，也可以访问。
## 成员常量
关键字：`const` 必须初始化，不能赋值。

常量在表现上与静态字段非常相似，它们对所有实例都是一样的，没有实力对象也可以被访问。真正与静态字段不同的是常量没用自己的存储地址，而是在编译时被编译器替换掉。

## 属性
尽管属性与字段相似，但和字段不同，属性是一个**函数成员**。

属性本身是不分配内存地址的。由访问器决定如何处理发生来的数据，以及应该将什么数据发送出去。

set访问器为属性赋值（只设置set访问器则为只写属性），get访问器从属性获取值（值设置了get访问器则为只读属性）。

静态属性和静态字段一样可以用`using Static`的方式访问。
```
Class Program
{
    private int theRealValue;   //字段：分配内存
    Public int MyValue          //属性：未分配内存
    {
        set{ this.theRealValue=value; }
        get{ return this.theRealValue; }
    }
}
```
## readonly修饰符
字段可以使用readonly修饰符声明。类似于const修饰符，一旦值设定就不能改变了。

const字段只能在声明语句中初始化，readonly字段可以在下列任何位置赋值。

const字段的值必须在编译时决定，而readonly字段可以在运行时决定。

const字段的行为总是静态的，而readonly字段可以是实例字段也可以用static修饰符声明作为静态字段。并且readonly字段在内存中有地址。

<br>

-------
# 索引器

---